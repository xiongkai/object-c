//
//  main.m
//  10-Category分类
//
//  Created by 熊凯 on 2017/4/16.
//  Copyright © 2017年 熊凯. All rights reserved.
//

#import <Foundation/Foundation.h>
#import "Animal.h"
#import "Animal+MJ.h"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        // Category分类可以在不修改原有类的情况下为该类扩充一些方法，
        //注意分类不能为原类增加成员变量只能增加方法
        //在分类中定义@property只能生成getter setter方法声明，但是不会生成getter setter方法的实现,
        //@synthesize不允许在分类中使用
        //分类中是无法访问只在主类的实现中声明和实现的方法
        //分类中可以访问原类的声明中手动定义的成员变量和方法以及@property生成的方法，但是访问不到@property生成的成员变量
        //分类中声明的方法，在分类的实现中不要求被实现
        /*基本与类的声明和实现一样，只是行A和行B的写法不一样而已，声明部分不需要写继承，，声明和实现部分在类名后要用小括号写上分类的名称
        //如果分类中对原类中的方法进行了重写，那么在导入分类的头文件时调用该方法，执行的是分类中的方法，因为分类中的方法优先级要高于原类
         //如果多个分类中都有相同的方法，那么在导入了分类头文件时调用这个相同的方法，将会调用最后被编译的分类中定义的方法
         //即优先级：最后编译的分类 》 之前被编译的分类 》原类
         @interface 目标类名(分类的名称)//A
         
         @end
         
         @implementation 目标类名(分类类名)//B
         
         @end
         */
        Animal *animal1 = [[Animal alloc]initWidthName:@"haha" andAge:10];
        //其中我们为Animal定义了分类，并扩展了一个myPrint方法
        [animal1 myPrint];//需要把分类的头文件掉入道调用文件中才能访问到分类中的扩展方法
        animal1.ext =1;
        //分类还可以对系统的类扩充方法
        
        
        //Extension:延展---和Category类似知识延展是没有名称
        //1.延展没有实现只有声明，他和主类共用同一个类的实现
        //---可以将Extension的类声明看作是将主类的声明分拣分开写了；它里面的写法和类声明中的写法一样
        //2.延展中可以定义成员变量
        //3.延展中可以使用@property：会自动生成方法声明和实现及成员变量；；；
        //4.延展可以声明方法
        //5.extension中声明的方法要求在类实现中进行实现
        //当延展独占一个.h文件时，那么它里面的成员变量，方法和属性的访问限制和写在主类中一样
        //当延展写在了.m文件即主类的实现中时，它里面的成员变量，方法和属性都只能在当前类中被访问到
        //延展一般不会独占一个.h文而是和主类的实现写在同一个.m文件当中，所以延展的应用场景是为主类扩展只能在本类内部访问的成员和方法
        
        //category是对原类进行扩展方法，是在运行期进行匹配
        //extension是原类的一部分，在编译器与原类组合形成一个完整的类
    }
    return 0;
}
