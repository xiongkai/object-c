//
//  main.m
//  03-第一个oc类
//
//  Created by 熊凯 on 2017/4/11.
//  Copyright © 2017年 熊凯. All rights reserved.
//

#import <Foundation/Foundation.h>
//一个完整的oc类必须要有声明和实现，而且必须继承NSObject（所有类的父类）

#pragma mark -
//类的声明
@interface Car : NSObject
{   //此位置的大括号范围是用来声明成员变量的，声明成员变量时必须写在此大括号内，方法不能声明在此大括号内
    
    /*成员变量的访问权限只受其上方的最近的访问权限修饰符影响，也即访问修饰符所影响的属性从声明处开始至下一个访问修饰符为止。
     如下：wheels,speed权限为public-----而age为package权限
     //访问修饰符只能用来修饰成员变量
     @public：公开的----允许任何位置使用该类的对象直接使用（对象名->成员变量名）形式访问
     @protected：受保护的,默认权限修饰符----允许该类及其子类的实力对象内部中直接访问该属性
     @package：包范围的----同一个框架内可以访问
     @private：私有的----只允许在该类的实例对象内部访问
     */
    //成员变量的未进行显示初始化，其默认值为对应类型的零值
    //成员变量不允许使用c语言的static进行修饰，也不能修饰方法，但是可以修饰方法中的局部变量。
    //其他用法和c语言中一样，可以修饰全局变量和函数
    @public//A
    int whells;
    int speed;
    @package//B
    int age;
    @protected//c
    int money;
    @private
    NSString *color;
}
void haha();
//oc方式的成员方法的声明----类中声明定义方法只能使用oc的方式，不能使用c语言的声明定义函数的方式
//方法只能定义在类中，成员方法只能由一个对象调用，
//而函数可以定义声明在除@interface与@implementation之中大括号即定义成员变量区域外文件的任何位置即函数直属于文件
//即便函数定义在了类的声明和实现之中也不意味着期可以通过类或对象调用，
//上面已经说过了，函数直属于文件，和写在类声明定义外一样，只要在使用前声明过就可以通过编译
//"-(返回类型) 方法名部分1:(参数1类型)参数名1 [方法名部分2]:(参数2类型)参数名2"
-(void) run;
-(void) run:(NSString *)streetName widthPeople:(NSString *)name;
//成员方法以减号开头----类方法以加号开头-----其他的写法规则一致
//类方法和成员方法除开头加减号不一样其他的都可以一样，因为类方法与成员方法所属的对象是一样，前者为当前类，后者为该类对应的对象
//由于类方法不依赖于对象所以是无法直接在类类部调用成员变量和成员方法
//但是成员方法是可以访问成员变量和类方法
//在类中调用类方法与在类外调用类方法一样
/**在类中的成员方法中调用成员方法或成员变量可以将在类外调用成员变量或成员方法的的对象名替换为self关键字
 *当然在调用成员变量时可以省略self关键字直接写变量名即可----self为指向当前对象即自身的指针变量
 *
 *在类中的类方法中调用类方法也可以使用self，只需要将在类外调用类方法格式中的类名替换成self关键字即可
 *此时self代表当前的class对象的指针变量
 */
//oc方式的类方法声明
//"+(返回类型) 方法名部分1:(参数1类型)参数名 [方法名部分2]:(参数2类型)参数名2"
+(void) run:(NSString *)streetName widthPeople:(NSString *)name;

@end

#pragma mark -
//类的实现
@implementation Car
{
    //与interface中定义的成员变量不能同名
    //在类的实现中定义的成员变量默认是私有的即private
    //即便定义为其他的访问权限也没用，因为我们一般引入的是类的声明的头文件，所以此时不管是什么访问权限都是可以视为私有的
    //只在类的实现中定义了的，只能在该类内部进行访问即全部为私有的，除非类的实现部分引入到了调用文件内
}

//如果方法只有实现而没有声明那么他就为一个私有的方法，只能在本类中访问调用
//方法的实现
-(void) run
{
    NSLog(@"I'm run （成员方法）%@ %d",self->color,money);//使用self在当前类的成员方法中调用成员变量
}

-(void) run:(NSString *)streetName widthPeople:(NSString *)name
{
    [self run];//使用self在当前类的成员方法中调用成员方法
    NSLog(@"I'm run width %@ on %@ road",name,streetName);
}

+(void) run
{
    NSLog(@"I'm run (类方法)");
}

+(void) run:(NSString *)streetName widthPeople:(NSString *)name
{
    [self run];//使用self在当前类的类方法中调用类方法
    NSLog(@"I'm run width %@ on %@ road",name,streetName);
}

@end

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        //oc中执行一个类的行为书写格式：[执行者(类名或对象) 执行行为[方法名]]
        //创建一个实例对象：[类名 new]-------new方法返回创建的对象的地址即是一个指针
        //oc中只能使用指针访问对象，即智能使用指针变量保存NSObject及其子类对象
        Car *car1 = [Car new];
        //在类外直接访问成员变量或成员方法：对象指针变量->成员变量    对象.成员变量 ---------oc中的类本质是一个结构体
        car1->whells = 4;
        car1->age = 5;
        car1->speed = 200;
        (*car1).speed = 201;
        //类外访问对象的方法：[对象指针变量 方法名]  或 [对象指针变量 方法名部分1:实参1 方法名部分2:实参2]
        //使用一个对象调用其方法默认只会调用对应的成员方法，而不会调用其类方法，如果调用其类方法则会报错，这一点与java不同
        //无参数方法调用
        [car1 run];
        //有参数方法调用
        [car1 run:@"嘉园路" widthPeople:@"刘诗诗"];
        //每一个对象都有一个isa的指针变量，该指针变量指向该类的类对象（类也是一个对象）
        //car1->isa;
        //匿名对象----即所创建的对象为赋值给任何变量--由于没有使用变量保存，使用一次后你就无法访问到它了
        [[Car new] run];
        
        //c语言中调用未声明或定义的函数等编译有警告不会报错，但是链接会报错
        //oc弱语法--调用未声明定义的函数或方法，编译有告警不会报错，但是如果是未声明定义的函数遵循c语言的规则链接时报错，如果是方法仍然会通过只有在运行时才会报错
        
        //类外访问类方法[类名 类方法名] 或[类名 类方法名部分1:实参1 类方法名部分2:实参2]
        //或[[对象 class] 类方法名部分1:实参1 类方法名部分2:实参2]----其中class为每一个对象的成员变量可以获取到它所属的类对象即其对应的class对象
        //使用类调用方法只能调用其类方法
        [Car run:@"珞瑜路" widthPeople:@"柳岩"];
        //类本身也是一个对象，是一种Class类型的对象
        [[car1 class] run:@"大马路" widthPeople:@"大哥大"];
        
        //oc对象在内存中存储的中只有成员变量，而要调用的方法还是在其对应的类对象中，
        //调用方法时是通过每个对象的isa指针变量来间接调用，isa就是对象所属类的类对象
    }
    return 0;
}
